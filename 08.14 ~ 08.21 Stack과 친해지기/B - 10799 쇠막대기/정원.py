B, result, S, j = input(), 0, [], 0 # bar, result, stack, laser index
L = [i for i in range(1, len(B)) if B[i-1]+B[i] == '()'] # laser
# print(L)
for i in range(len(B)):
    # print(S, i, L[j])
    if B[i] == '(': S.append(B[i]) # 쇠막대기 시작 or 레이저 시작
    elif B[i] == ')': # 쇠막대기 끝 or 레이저 끝
        if i == L[j]: 
            S.pop()
            result += len(S) # 레이저로 컷팅
            if j < len(L)-1: j += 1 # 쇠막대기? 레이저? 체크
        else: S.pop(); result += 1 # 쇠막대기 끝
print(result)

"""
쇠막대기의 시작('(')을 스택에 넣는다
레이저가 등장하면 등장한 모든 쇠막대기는 잘려나가고
len(stack) 만큼의 잘린 부분이 생겨난다
쇠막대기가 끝나면 바로 직전 레이저에서 잘려나갔기 때문에
잘린 마지막 파편을 result++ 하고, 스택에서 꺼낸다
위 과정을 반복하되
레이저는 시작과 끝에 존재할 수 있으니 조심

<코드 리팩토링>
레이저인지 확인하는 방법으로
쇠막대기 입력에서 레이저의 인덱스를 추출하고 저장하였다
')'가 등장할 때의 인덱스가, 레이저인덱스(L)에 있으면 레이저고
레이저인덱스에 없으면 레이저가 아닌 닫는 쇠막대기다
이 레이저인덱스를 확인하는 과정에서 in 연산자를 사용했던
처음 제출한 코드는 608ms의 시간이 걸렸고
인덱스를 직접 잡아주는 방식으로 코드를 바꿔주니
156ms가 걸리면서, 약 4배의 시간단축을 보여주었다
in이 진짜 느리긴 느리구나.. 실버 상위 문제부터는
사용하기가 망설여진다
"""

"""
if '()' in Stack
"""